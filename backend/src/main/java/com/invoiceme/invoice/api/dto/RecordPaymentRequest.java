package com.invoiceme.invoice.api.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Positive;

import java.math.BigDecimal;
import java.time.LocalDate;

/**
 * Request DTO for recording a payment against an invoice.
 */
public record RecordPaymentRequest(
    @NotNull(message = "Amount is required")
    @Positive(message = "Amount must be positive")
    BigDecimal amount,

    @NotBlank(message = "Currency is required")
    @Pattern(regexp = "^[A-Z]{3}$", message = "Currency must be a valid ISO 4217 code (3 uppercase letters)")
    String currency, // ISO 4217 currency code (e.g., "USD")

    @NotNull(message = "Payment date is required")
    @JsonProperty("paymentDate")
    LocalDate paymentDate,

    @NotBlank(message = "Payment method is required")
    @Pattern(regexp = "^(CASH|BANK_TRANSFER|CREDIT_CARD|DEBIT_CARD|CHECK|WIRE_TRANSFER|OTHER)$", 
             message = "Payment method must be one of: CASH, BANK_TRANSFER, CREDIT_CARD, DEBIT_CARD, CHECK, WIRE_TRANSFER, OTHER")
    String method, // PaymentMethod enum value

    String reference // optional transaction reference
) {
    /**
     * Converts this DTO to a RecordPaymentCommand.
     *
     * @param invoiceId the invoice ID
     * @param paymentId the payment ID (generated by controller)
     * @return RecordPaymentCommand
     */
    public com.invoiceme.invoice.application.commands.RecordPaymentCommand toCommand(
        java.util.UUID invoiceId,
        java.util.UUID paymentId
    ) {
        return new com.invoiceme.invoice.application.commands.RecordPaymentCommand(
            invoiceId,
            paymentId,
            amount,
            currency,
            paymentDate,
            method,
            reference
        );
    }
}

